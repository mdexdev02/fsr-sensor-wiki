---
sidebar_position: 6
title: ì‘ìš© ë¶„ì•¼
description: FSR ì„¼ì„œì˜ ë‹¤ì–‘í•œ í™œìš© ë¶„ì•¼ì™€ ì‹¤ì œ ì ìš© ì‚¬ë¡€ë¥¼ ì†Œê°œí•©ë‹ˆë‹¤
keywords: [FSR ì‘ìš©, ì˜ë£Œ í—¬ìŠ¤ì¼€ì–´, ì‚°ì—… ìë™í™”, êµìœ¡, ê²Œì„]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# FSR ì„¼ì„œ ì‘ìš© ë¶„ì•¼

FSR ì„¼ì„œëŠ” ë‹¤ì–‘í•œ ì‚°ì—… ë¶„ì•¼ì—ì„œ í˜ì‹ ì ì¸ ì†”ë£¨ì…˜ì„ ì œê³µí•©ë‹ˆë‹¤.

## ğŸ¥ ì˜ë£Œ ë° í—¬ìŠ¤ì¼€ì–´

### ì¬í™œ ì¹˜ë£Œ

#### ìì„¸ êµì • ì‹œìŠ¤í…œ
```cpp
// ìì„¸ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì˜ˆì œ
class PostureMonitor {
  private:
    int sensors[4] = {A0, A1, A2, A3}; // 4ê°œ ì„¼ì„œ
    int baseline[4];
    
  public:
    void calibrate() {
      Serial.println("ì˜¬ë°”ë¥¸ ìì„¸ë¥¼ ìœ ì§€í•˜ì„¸ìš”...");
      delay(3000);
      for(int i = 0; i < 4; i++) {
        baseline[i] = analogRead(sensors[i]);
      }
    }
    
    String checkPosture() {
      int readings[4];
      for(int i = 0; i < 4; i++) {
        readings[i] = analogRead(sensors[i]);
      }
      
      // ì¢Œìš° ê· í˜• ì²´í¬
      int leftSum = readings[0] + readings[1];
      int rightSum = readings[2] + readings[3];
      int balance = abs(leftSum - rightSum);
      
      if(balance > 200) return "ì¢Œìš° ë¶ˆê· í˜•";
      
      // ì „í›„ ê· í˜• ì²´í¬
      int frontSum = readings[0] + readings[2];
      int backSum = readings[1] + readings[3];
      int frontBack = abs(frontSum - backSum);
      
      if(frontBack > 200) return "ì „í›„ ë¶ˆê· í˜•";
      
      return "ì •ìƒ ìì„¸";
    }
};
```

#### ë³´í–‰ ë¶„ì„
- **ìš©ë„**: ë³´í–‰ íŒ¨í„´ ë¶„ì„, ì¬í™œ ì§„ë„ ëª¨ë‹ˆí„°ë§
- **ì„¼ì„œ ë°°ì¹˜**: ì‹ ë°œ ê¹”ì°½ ë‚´ ë‹¤ì¤‘ ì„¼ì„œ
- **ì¸¡ì • í•­ëª©**: 
  - ë°œ ì••ë ¥ ë¶„í¬
  - ë³´í–‰ ì£¼ê¸°
  - ì²´ì¤‘ ì´ë™ íŒ¨í„´

### í™˜ì ëª¨ë‹ˆí„°ë§

<Tabs>
  <TabItem value="bed" label="ì¹¨ëŒ€ ëª¨ë‹ˆí„°ë§" default>

**ìš•ì°½ ë°©ì§€ ì‹œìŠ¤í…œ**
- ì¥ì‹œê°„ ê°™ì€ ìì„¸ ê°ì§€
- ì••ë ¥ ë¶„í¬ ë§¤í•‘
- ìë™ ì•Œë¦¼ ì‹œìŠ¤í…œ

```javascript
// ì••ë ¥ ë§¤íŠ¸ë¦­ìŠ¤ ì‹œê°í™”
function visualizePressureMap(sensorData) {
  const heatmap = [];
  for(let i = 0; i < 8; i++) {
    for(let j = 0; j < 8; j++) {
      const pressure = sensorData[i][j];
      const color = getHeatmapColor(pressure);
      heatmap.push({x: i, y: j, color: color});
    }
  }
  return heatmap;
}
```

  </TabItem>
  <TabItem value="wheelchair" label="íœ ì²´ì–´ ëª¨ë‹ˆí„°ë§">

**ìŠ¤ë§ˆíŠ¸ íœ ì²´ì–´ ì¿ ì…˜**

ì••ë ¥ ë¶„ì‚° ëª¨ë‹ˆí„°ë§, ìì„¸ ë³€ê²½ ì•Œë¦¼, ì•‰ì€ ì‹œê°„ ì¶”ì  ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.

  </TabItem>
  <TabItem value="prosthetic" label="ì˜ìˆ˜/ì˜ì¡±">

**ê°ê° í”¼ë“œë°± ì‹œìŠ¤í…œ**

ê·¸ë¦½ ê°•ë„ ì œì–´, ë¬¼ì²´ ê°ì§€, ì´‰ê° í”¼ë“œë°± ê¸°ëŠ¥ì„ í†µí•´ ìì—°ìŠ¤ëŸ¬ìš´ ê°ê°ì„ ì œê³µí•©ë‹ˆë‹¤.

  </TabItem>
</Tabs>

## ğŸ­ ì‚°ì—… ìë™í™”

### í’ˆì§ˆ ê²€ì‚¬

#### ì œí’ˆ ì••ë ¥ í…ŒìŠ¤íŠ¸
```cpp
// í’ˆì§ˆ ê²€ì‚¬ ì‹œìŠ¤í…œ
class QualityControl {
  const float MIN_PRESSURE = 5.0;  // N
  const float MAX_PRESSURE = 15.0; // N
  
  bool testProduct(int sensorPin) {
    float pressure = measurePressure(sensorPin);
    
    if(pressure < MIN_PRESSURE) {
      Serial.println("ë¶ˆëŸ‰: ì••ë ¥ ë¶€ì¡±");
      return false;
    }
    if(pressure > MAX_PRESSURE) {
      Serial.println("ë¶ˆëŸ‰: ê³¼ë„í•œ ì••ë ¥");
      return false;
    }
    
    Serial.println("í•©ê²©");
    return true;
  }
  
  void batchTest(int batchSize) {
    int passed = 0;
    for(int i = 0; i < batchSize; i++) {
      if(testProduct(A0)) passed++;
      delay(1000);
    }
    
    float passRate = (float)passed / batchSize * 100;
    Serial.print("í•©ê²©ë¥ : ");
    Serial.print(passRate);
    Serial.println("%");
  }
};
```

### ë¡œë´‡ ê³µí•™

#### ë¡œë´‡ ê·¸ë¦¬í¼
- **ì ìš©**: ë¬¼ì²´ íŒŒì§€ë ¥ ì œì–´
- **ì¥ì **: 
  - ë¶€ë“œëŸ¬ìš´ ë¬¼ì²´ ì†ìƒ ë°©ì§€
  - ë¯¸ë„ëŸ¬ì§ ê°ì§€
  - ì ì‘í˜• ê·¸ë¦½

#### í˜‘ë™ ë¡œë´‡ (Cobot)
```cpp
// ì¶©ëŒ ê°ì§€ ì‹œìŠ¤í…œ
class CollisionDetection {
  const int COLLISION_THRESHOLD = 500;
  bool emergencyStop = false;
  
  void checkCollision(int sensorArray[], int size) {
    for(int i = 0; i < size; i++) {
      if(analogRead(sensorArray[i]) > COLLISION_THRESHOLD) {
        emergencyStop = true;
        stopRobot();
        Serial.println("ì¶©ëŒ ê°ì§€! ë¹„ìƒ ì •ì§€");
        break;
      }
    }
  }
  
  void stopRobot() {
    // ëª¨ë“  ëª¨í„° ì •ì§€
    digitalWrite(MOTOR_ENABLE, LOW);
    // ì•ŒëŒ ë°œìƒ
    digitalWrite(ALARM_PIN, HIGH);
  }
};
```

## ğŸ® ì—”í„°í…Œì¸ë¨¼íŠ¸

### ê²Œì„ ì»¨íŠ¸ë¡¤ëŸ¬

#### ì••ë ¥ ê°ì‘ ë²„íŠ¼
```cpp
// ì•„ë‚ ë¡œê·¸ ë²„íŠ¼ êµ¬í˜„
class PressureSensitiveButton {
  private:
    int pin;
    int threshold = 100;
    int maxValue = 900;
    
  public:
    PressureSensitiveButton(int p) : pin(p) {}
    
    float getPressureLevel() {
      int raw = analogRead(pin);
      if(raw < threshold) return 0;
      if(raw > maxValue) return 1.0;
      
      return (float)(raw - threshold) / (maxValue - threshold);
    }
    
    // ê²Œì„ ì•¡ì…˜ ë§¤í•‘
    void processGameAction() {
      float pressure = getPressureLevel();
      
      if(pressure == 0) {
        // ë²„íŠ¼ ë¯¸ì…ë ¥
      } else if(pressure < 0.3) {
        sendCommand("WALK");
      } else if(pressure < 0.7) {
        sendCommand("RUN");
      } else {
        sendCommand("SPRINT");
      }
    }
};
```

### ì „ì ì•…ê¸°

#### ë””ì§€í„¸ ë“œëŸ¼ íŒ¨ë“œ
- **êµ¬ì„±**: ë‹¤ì¤‘ FSR ì„¼ì„œ ë°°ì—´
- **ê¸°ëŠ¥**:
  - ë²¨ë¡œì‹œí‹° ê°ì§€
  - ë©€í‹°í„°ì¹˜ ì§€ì›
  - ì• í”„í„°í„°ì¹˜

#### MIDI ì»¨íŠ¸ë¡¤ëŸ¬
```cpp
// MIDI ë“œëŸ¼ íŒ¨ë“œ
class MIDIDrumPad {
  const int MIDI_CHANNEL = 1;
  const int DRUM_NOTE = 36; // Kick drum
  
  void hitDetected(int velocity) {
    // MIDI Note On
    Serial.write(0x90 | MIDI_CHANNEL);
    Serial.write(DRUM_NOTE);
    Serial.write(velocity); // 0-127
    
    delay(10);
    
    // MIDI Note Off
    Serial.write(0x80 | MIDI_CHANNEL);
    Serial.write(DRUM_NOTE);
    Serial.write(0);
  }
  
  void process() {
    int reading = analogRead(A0);
    if(reading > 100) {
      int velocity = map(reading, 100, 1023, 1, 127);
      hitDetected(velocity);
    }
  }
};
```

## ğŸ“ êµìœ¡ ë° ì—°êµ¬

### STEAM êµìœ¡

#### ì´ˆë“± êµìœ¡ í”„ë¡œì íŠ¸
1. **ì••ë ¥ ê°ì§€ ì‹ í˜¸ë“±**
   - ë³´í–‰ì ë²„íŠ¼
   - LED ì œì–´
   - íƒ€ì´ë¨¸ ê¸°ëŠ¥

2. **ë””ì§€í„¸ ì²´ì¤‘ê³„**
   - ë‹¨ìœ„ ë³€í™˜ í•™ìŠµ
   - ë°ì´í„° ê¸°ë¡
   - ê·¸ë˜í”„ ê·¸ë¦¬ê¸°

#### ì¤‘ê³ ë“± êµìœ¡
```python
# Pythonì„ ì´ìš©í•œ ë°ì´í„° ë¶„ì„ í”„ë¡œì íŠ¸
import serial
import matplotlib.pyplot as plt
import numpy as np

class FSRDataAnalyzer:
    def __init__(self, port):
        self.ser = serial.Serial(port, 9600)
        self.data = []
        
    def collect_data(self, duration):
        start_time = time.time()
        while time.time() - start_time < duration:
            if self.ser.in_waiting:
                value = int(self.ser.readline().decode().strip())
                self.data.append(value)
        
    def analyze(self):
        # í†µê³„ ë¶„ì„
        mean = np.mean(self.data)
        std = np.std(self.data)
        
        # ì£¼íŒŒìˆ˜ ë¶„ì„ (FFT)
        fft = np.fft.fft(self.data)
        freq = np.fft.fftfreq(len(self.data))
        
        return {
            'mean': mean,
            'std': std,
            'frequency': freq,
            'fft': fft
        }
```

### ì—°êµ¬ ì‘ìš©

#### ì¸ê°„-ì»´í“¨í„° ìƒí˜¸ì‘ìš© (HCI)
- í„°ì¹˜ ì¸í„°í˜ì´ìŠ¤ ì—°êµ¬
- í–…í‹± í”¼ë“œë°± ì‹œìŠ¤í…œ
- ì œìŠ¤ì²˜ ì¸ì‹

#### ìƒì²´ì—­í•™ ì—°êµ¬
- ê·¼ìœ¡ í™œë™ ëª¨ë‹ˆí„°ë§
- ê´€ì ˆ ì••ë ¥ ì¸¡ì •
- ìš´ë™ ë¶„ì„

## ğŸš— ìë™ì°¨ ì‚°ì—…

### ì•ˆì „ ì‹œìŠ¤í…œ

#### ì‹œíŠ¸ ì ìœ  ê°ì§€
```cpp
// ì‹œíŠ¸ë²¨íŠ¸ ê²½ê³  ì‹œìŠ¤í…œ
class SeatOccupancy {
  const int OCCUPANCY_THRESHOLD = 300; // ~5kg
  bool seatbeltWarning = false;
  
  bool isOccupied() {
    int sum = 0;
    // ì‹œíŠ¸ì˜ ì—¬ëŸ¬ ì§€ì  ì¸¡ì •
    for(int i = 0; i < 4; i++) {
      sum += analogRead(A0 + i);
    }
    return (sum / 4) > OCCUPANCY_THRESHOLD;
  }
  
  void checkSeatbelt() {
    if(isOccupied() && !isSeatbeltFastened()) {
      activateWarning();
    }
  }
};
```

### ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤
- ìŠ¤í‹°ì–´ë§ íœ  í„°ì¹˜ ê°ì§€
- ê¸°ì–´ ë…¸ë¸Œ ê·¸ë¦½ ì„¼ì„œ
- í˜ë‹¬ ì••ë ¥ ëª¨ë‹ˆí„°ë§

## ğŸ  ìŠ¤ë§ˆíŠ¸ í™ˆ

### ë³´ì•ˆ ì‹œìŠ¤í…œ

#### ì¹¨ì… ê°ì§€
- ë°”ë‹¥ ì••ë ¥ ë§¤íŠ¸
- ì°½ë¬¸/ë¬¸ ì••ë ¥ ì„¼ì„œ
- ìš¸íƒ€ë¦¬ ë“±ë°˜ ê°ì§€

### ìƒí™œ í¸ì˜

#### ìŠ¤ë§ˆíŠ¸ ë§¤íŠ¸ë¦¬ìŠ¤
```javascript
// ìˆ˜ë©´ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
class SleepMonitor {
  constructor() {
    this.pressureMap = new Array(8).fill(new Array(8).fill(0));
    this.movementHistory = [];
  }
  
  analyzeSleepQuality() {
    const movements = this.countMovements();
    const position = this.detectSleepPosition();
    
    let quality = 100;
    quality -= movements * 2; // ì›€ì§ì„ ë‹¹ 2ì  ê°ì 
    
    if(position === 'optimal') quality += 10;
    
    return {
      score: Math.max(0, quality),
      movements: movements,
      position: position
    };
  }
}
```

## ğŸ“Š ì‹¤ì œ êµ¬í˜„ ì‚¬ë¡€

### ì„±ê³µ ì‚¬ë¡€ 1: ë³‘ì› ì¬í™œ ì„¼í„°
- **ë¬¸ì œ**: ìˆ˜ë™ ìì„¸ í‰ê°€ì˜ í•œê³„
- **í•´ê²°**: FSR ê¸°ë°˜ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
- **ê²°ê³¼**: ì¬í™œ íš¨ìœ¨ 40% í–¥ìƒ

### ì„±ê³µ ì‚¬ë¡€ 2: ì œì¡° ë¼ì¸
- **ë¬¸ì œ**: ìˆ˜ë™ í’ˆì§ˆ ê²€ì‚¬
- **í•´ê²°**: ìë™ ì••ë ¥ í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ
- **ê²°ê³¼**: ë¶ˆëŸ‰ë¥  75% ê°ì†Œ

### ì„±ê³µ ì‚¬ë¡€ 3: êµìœ¡ ê¸°ê´€
- **ë¬¸ì œ**: ì¶”ìƒì ì¸ ë¬¼ë¦¬ ê°œë…
- **í•´ê²°**: FSR ì‹¤ìŠµ í‚¤íŠ¸ ë„ì…
- **ê²°ê³¼**: í•™ìŠµ ì´í•´ë„ 60% í–¥ìƒ

## ğŸ’¡ í”„ë¡œì íŠ¸ ì•„ì´ë””ì–´

### ì´ˆê¸‰ í”„ë¡œì íŠ¸
1. LED ë°ê¸° ì œì–´
2. ê°„ë‹¨í•œ ì „ì ì €ìš¸
3. í„°ì¹˜ í”¼ì•„ë…¸

### ì¤‘ê¸‰ í”„ë¡œì íŠ¸
1. ìì„¸ êµì • ì•Œë¦¼ ì‹œìŠ¤í…œ
2. ìŠ¤ë§ˆíŠ¸ ë„ì–´ë§¤íŠ¸
3. ì••ë ¥ ê°ì‘ ê²Œì„ ì»¨íŠ¸ë¡¤ëŸ¬

### ê³ ê¸‰ í”„ë¡œì íŠ¸
1. ë³´í–‰ ë¶„ì„ ì‹œìŠ¤í…œ
2. ë¡œë´‡ ì´‰ê° ì„¼ì„œ
3. IoT ê¸°ë°˜ ì••ë ¥ ëª¨ë‹ˆí„°ë§

:::tip ì‹œì‘í•˜ê¸°
ê° ì‘ìš© ë¶„ì•¼ì˜ ì‹¤ì œ êµ¬í˜„ ë°©ë²•ì€ [íŠœí† ë¦¬ì–¼ ì„¹ì…˜](/docs/tutorials)ì—ì„œ 
ë‹¨ê³„ë³„ë¡œ í•™ìŠµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
:::

## ë‹¤ìŒ ë‹¨ê³„

- [ì œí’ˆ ì„ íƒ ê°€ì´ë“œ](/docs/products) - ì‘ìš©ë³„ ìµœì  ì„¼ì„œ
- [ì²« í”„ë¡œì íŠ¸ ì‹œì‘](/docs/tutorials/beginner/first-project) - ì‹¤ìŠµ ì‹œì‘
- [ê³ ê¸‰ í”„ë¡œì íŠ¸](/docs/tutorials/advanced) - ì‹¬í™” ì‘ìš©